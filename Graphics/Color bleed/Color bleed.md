Aka dilatation

Create a mask/list to store which pixel need computation. Compute until no more pixel remains.
Can be parallelize

	# Bleed colors in transparent area to 8px distance
	convert image.png \( +clone -blur 8x1 -clone 0 -composite \) +swap -compose Copy_Opacity -composite image_bleeded.png
	# To see the effect, add `-alpha off` before the output filename
	# To clean transparent pixels (revert the effect), use `convert image.png -channel rgb -fx "a==0?0:s" image.png`

	# From already bleeding image, if you want to clear area outsize 8 pixels of image generated by alpha-bleeding
	convert image_bleeded.png \( +clone -alpha off \) \( +clone -alpha extract -blur 8x65000 -threshold 0 -negate -alpha Copy -fill black -opaque white -clone 1 +swap -compose over -composite -alpha on \) -delete 1 +swap -compose Copy_Opacity -composite image_bleeded_optimized.png

See [Texture format - alpha bleeding](Texture format#Optimizations)

- [Automated and Improved UV Dilation](http://shaderbits.com/blog/uv-dilation)
- [urraka/alpha-bleeding: Small tool to bleed the border colors of an image with transparency through the pixels that are fully transparent.](https://github.com/urraka/alpha-bleeding)
- https://github.com/gemserk/imageprocessing
- https://github.com/JFixby/TextureBleeder same base as gemserk/imageprocessing and an other from wrebecca
- libgdx Texture packer's bleed setting https://github.com/libgdx/libgdx/blob/master/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/ColorBleedEffect.java same base as gemserk/imageprocessing

> Code for Dilation. Keep in mind this code may not be flexible for all types of UV layouts and could easily be improved by adding further checks on the offset neighbor finding code. It can be modified with a few changes to work with regular color textures by changing the sample variables to float4's and using alpha instead of rgb for the 0 checks. Two offset samples could even be taken to use curvature instead of slope as the input which could give even more accurate result. 

	//////////////// UV Positional Dilation ///////////////////////////
	//** Tex **// Input Texture Object storing Volume Data
	//** UV **// Input float2 for UVs
	//** TextureSize **// Resolution of render target
	//** MaxSteps **// Pixel Radius to search
	
	
	float texelsize = 1 / TextureSize;
	float mindist = 10000000;
	float2 offsets[8] = {float2(-1,0), float2(1,0), float2(0,1), float2(0,-1), float2(-1,1), float2(1,1), float2(1,-1), float2(-1,-1)};
	
	float3 sample = Tex.SampleLevel(TexSampler, UV, 0);
	float3 curminsample = sample;
	
	if(sample.x == 0 && sample.y == 0 && sample.z == 0)
	{
	    int i = 0;
	    while(i < MaxSteps)
	    { 
	        i++;
	        int j = 0;
	        while (j < 8)
	        {
	            float2 curUV = UV + offsets[j] * texelsize * i;
	            float3 offsetsample = Tex.SampleLevel(TexSampler, curUV, 0);
	
	            if(offsetsample.x != 0 || offsetsample.y != 0 || offsetsample.z != 0)
	            {
	                float curdist = length(UV - curUV);
	
	                if (curdist < mindist)
	                {
	                    float2 projectUV = curUV + offsets[j] * texelsize * i * 0.25;
	                    float3 direction = Tex.SampleLevel(TexSampler, projectUV, 0);
	                    mindist = curdist;
	
	                    if(direction.x != 0 || direction.y != 0 || direction.z != 0)
	                    {
	                        float3 delta = offsetsample - direction;
	                        curminsample = offsetsample + delta * 4
	                    }
	
	                   else
	                    {
	                        curminsample = offsetsample;
	                    }
	                }
	            }
	            j++;
	        }
	    }
	}
	
	return curminsample;